= SimpleBot Documentation
:doctype: book
:source-highlighter: coderay
:listing-caption: Listing
:pdf-page-size: Letter
:toc: right
:toc-title: Table of Contents
:toclevels: 4
:imagesdir: ./

== Overview

SimpleBot is a simple chat bot engine for the Unity platform. Given input sentences, SimpleBot detects
the intent and then reply the reply sentence. Simple bot provide Amazon Echo style JSON configuration.
In addition, functions for practical applications such as state transitions or slot type matching are provided.

== Basic Usage

SimpleBot has `Simple.BotEngine` which manages the dialogue with the user following specified configuration.file.
We can create a `BotEngine` specifying the configuration file.

```
private void createBot()
{
    string settingFilePath = Application.dataPath + "/SimpleBot/Scenes/simple-bot-conf.json";
    string setting = File.ReadAllText(settingFilePath);
    ConfigurationLoader configurationLoader = new ConfigurationLoader();
    Configuration config = configurationLoader.loadFromString(setting);
    this.bot = new BotEngine(config);
}
```

After we create a `BotEngine` instance, the instance is ready to get input sentence.

```
public void RespondtoInput()
{
    var input = inputField.text;
    var reply = this.bot.replySentence(input);
    text.text = reply;
    inputField.text = "";
}
```

In the following sections, we learn the configurations and practical usage.

== Basic Configurations

This section starts from the simple SimpleBot configuration. SimpleBot has a JSON
formatted configuration file. The following is a tiny example.

```
{
  "intents": [
    {
      "name": "repeat",
      "match": {
        "type": "verbatim",
        "expressions": [ "repeat", "pardon me?" ]
      }
    }
  ],
  "responders":
  {
    "repeat": [
      {
        "responds": [ "Go straight." ],
      }
    ],
    "default": [{
      "target": "default",
      "responds": [ "Sorry I do not understand what you mean." ]
    }]
  }
}
```

In the above example, we see that the configuration files have two blocks (`intents` and `responders`).
We register `intents` to extract intent from input sentences. `responders` specify the handlers to output
the reply sentences for target intents.

### Intent settings

`Intents` blocks consist of a list of intent settings. We add a set of intents which we want make the `BotEngine`
to identify the intent of input sentences. Intents has three blocks, `name`, `match` and `effects`. The following
table shows the description of each block.

[cols="1,2", options="header"]
.elements of match block
|===
|Name
|Description

|name
|Name of the intent

|match
|Describe matching patterns. If the type is `verbatim`, we specify substring„ÄÅIf `template`, we add list of template patterns

|effects (optional)
|Describe effects of matching the intent from the users. This block contains the list of effects when the indent is detected.
|===

### Intent example

The following is a plain setting to identify if the user input is about weather.

```
"intents": [
    {
      "name": "weather",
      "match": {
        "type": "verbatim",
        "expressions": [ "forcast", "weather" ]
      }
    }
]
```

As we see intents block is a list and contains one intent block. The intent block has three elements `name`, `match`.
In the `match` block, we specify the matching expressions. `match` has two types of matching type. We specify matching
type in `type` element. SimpleBot provides two types of matching. `verbatim` and `template`. Next section shows the
types of intent matching.

### Verbatim matching

`verbatim` provides the plain matching, with which intent is match when the registered expression is contained in
the input sentence. In the `verbatim` match we specify intent by matching with registered expressions.
The following is the example shown in the previous section.

```
"intents": [
    {
      "name": "weather",
      "match": {
        "type": "verbatim",
        "expressions": [ "forcast", "weather" ]
      }
    }
]

```

With the `expressions` settings, SimpleBot identify the input is about weather when input
contains registered expressions `forcast` or `weather`.

### Template matching

Compared with `verbatim`, `template` type matching provides more powerful matching with `slots` and `types`.
The following settings contains one intent setting whose type is `template` and contains a `slots` block.

```
intents: [
        {
            "name": "weather-forcast",
            "match" : {
                "type" : "template",
                 "slots" : [{
                     "name" : "target-location",
                      "type" :  "locations"
                  } ]
                "patterns" : [ "weather forecast for #{target-location}?" ]
            }
        },
],
"types" :
[
   {
       "name" : "locations",
       "examples", ["Paris", "New York", "Tokyo"]
    }
]
```

The next section describe how we can make template intent using `types` and `slots`.

### Slots and Types

In the slots block, we specify a `type` in `types` block. `types`
block contains a list of types which contains a list of `examples`.
`example` contains a list of expressions, which are used in the
`slot` block in `template` type of intents to detect intent.

In the above configuration example, the type `location` is used in `slot`
named `target-location`.

The patterns of template type of intents can embed the slots. the pattern
matches the inputs which are expanded patterns such as `weather forecast for Paris`
or `weather forecast for New York`.

### Responder settings

`responders` is a list section in the configuration file, we add the responder
settings for the each target intent defined in `intents` block.

The following configuration, one intent `repeat` is defined in `intents` block.
The `responders` section has two block, for `repeat` and `default` targets. `repeat` target is applied when
the `BotEngine` detect the intent of inputs as `repeat`. `default` target is called when no intent is detected.

```
{
  "intents": [
    {
      "name": "repeat",
      "match": {
        "type": "verbatim",
        "expressions": [ "repeat", "pardon me?" ]
      }
    }
  ],
  "responders":
  {
    "repeat": [
      {
        "responds": [ "Go straight." ],
      }
    ],
    "default": [{
      "responds": [ "Sorry I do not understand what you mean." ]
    }]
  }
}
```

Each respond block contains `responds` element which has a list of respond sentences.
`BotEngine` select randomly the respond sentence from the list.

## Handling State

SimpleBot support state of dialogue. We can add the settings of state,
combining `effects` and `condition` blocks.

### Effect

Each intent of `intents` block supports `effects` block, where we can define
the effect of state, when the BotEngine identify the intent. `effects` has the following elements.

[cols="1,2", options="header"]
.types of effect
|===
|Name
|Description

|field
|property name
|type
|Specify type of the effect (`incr`, `decr`, or `set`)
|defaul
|Set the default value of the property
|===


```
"intents": [
    {
      "name": "whether",
      "match": {
        "type": "verbatim",
        "expressions": [ "forcast", "weather" ]
      },
      "effects" : [{
			    "field": "anger-level",
    			"type": "incr",
          "default": 0
		    }]
    }
]
```

In the above example, every time identifying the whether intent, the `angry-level` increased.
SimpleBot support the following types of effect.

[cols="1,2", options="header"]
.types of effect
|===
|Name
|Description

|incr
|Increments the value of specified property (NOTE: the type of the property must be integer)

|decr
|Decrements the value of specified property (NOTE: the type of the property must be integer)
|set
|Set the value of specified property (NOTE: the type of the property must be string)
|===

The states such as are used when the BotEngine select the responder using `condition`. In the next section,
we will learn the `responder` settings including usage of `condition`.

### Condition

The state defined in `state` block, can be used in matching `responder`.
The following example make use of state with `effect` and `condition`.

The effects of `location` block defined `failed-num` is incremented from 0 when the
`location` intent is identified. Then a respond block in the `location` block in
`reponders` defines `condition` block which defines the condition to apply the responder.
For responders with `condition` block does not applied even when the intent is the target
one, if the state does not meet the condition.


```
{
  "intents": [
      {
        "name": "location",
        "match": {
          "type": "verbatim",
          "expressions": [ "location", "office", "where" ]
        },
        "effects" : [{
  			    "field": "failed-num",
      			"type": "incr",
            "default": 0
  		    }]
      }
  ],
  "responders":
  {
    "location": [
      {
        "responds": [ "The conference is held in 321 room of O-nine building." ],
        "condition": {
          "must": [
            {
              "range": { "failed-num" : { "lte": 1 }}
            }
          ]
        }
      },
      {
        "responds": [ "Please call to the a responsible person, the number is +81-90-0004-49009." ],
        "condition": {
          "must": [
            {
              "range": { "failed-num" : { "gte": 2 }}
            }
          ]
        }
      }
    ],
    "default": [{
      "target": "default",
      "responds": [ "Sorry I do not understand what you mean." ]
    }]
  }
}
```

For `location` intent, the configuration file contains two responders both of them have `condition` block.
If the `failed-num` is less then or equals `1` first respond is applied otherwise the second one is applied.

## Samples

### Guide

### Continuous Integration

## FAQ

## Summary
